const P=e=>Math.round(e*1e10)/1e10,E=(e,a)=>P(Math.sqrt((a.x-e.x)*(a.x-e.x)+(a.y-e.y)*(a.y-e.y))),b=Math.PI,L=b*2,S=(e,a)=>{const n=a-e;return n>b&&n<L||n<0&&n>-b?-1:1},w=(e,a,n,l,o,h)=>{const s=Math.atan2(e.y-a.y,e.x-a.x),v=Math.atan2(n.y-a.y,n.x-a.x),t=Math.acos((l*l+h*h-o*o)/(2*l*h)),g=1/Math.tan(t/2),d=S(s,v),f=s+d*t/2;return{prev:s,next:v,main:t,vel:g,dir:d,bis:f}},I=Math.PI,T=(e,a,n)=>e.reduce((l,o)=>{const{x:h,y:s,angle:{prev:v,next:t},arc:{x:g,y:d,radius:f}}=o,x=o.angle.dir*-1,y=v+x*I/2,M=(x*I+t-v)%I,i=n-1,m=M/i,R=[];if(!m)return l.concat({x:h,y:s});for(let c=0;c<=i;c++)R.push({x:g+Math.cos(y+m*c)*f,y:d+Math.sin(y+m*c)*f});return l.concat(R)},[]),_=(e,a=0)=>{const n=e.length,l=[],o=[],h=[];e.forEach((t,g)=>{const d=e[(g-1+n)%n],f=e[(g+1)%n],x=E(d,t),y=E(d,f),M=E(t,f),i=w(d,t,f,x,y,M);i.main===0&&(i.main=Number.EPSILON,i.vel=Number.MAX_SAFE_INTEGER),i.main===b&&(i.vel=0);const m={x:t.x,y:t.y,angle:i,offset:0,arc:{radius:a,hit:a,lim:Math.min(M/i.vel,x/i.vel,t.r||0)},in:{length:x,rest:x},out:{length:M,rest:M},locked:!1,id:g,get prev(){return l[(g-1+n)%n]},get next(){return l[(g+1)%n]}};isNaN(i.main)&&(i.main=0,i.bis=i.prev||i.next,h.push(m)),typeof t.r=="number"&&(t.r===0?h.push(m):o.push(m)),l.push(m)}),h.forEach(t=>{t.angle.vel=0,t.arc.radius=0,N(t)}),l.forEach(t=>{t.arc.hit=Math.min(t.out.rest/(t.angle.vel+t.next.angle.vel),t.in.rest/(t.angle.vel+t.prev.angle.vel))});let s=k(o);for(;s;)C(s),s=k(o);for(s=k(l);s;)H(s,a),s=k(l);const v=l.map(t=>{const g=t.arc.radius/Math.sin(t.angle.main/2);return{id:t.id,x:t.x,y:t.y,angle:{main:P(t.angle.main),prev:t.angle.prev,next:t.angle.next,bis:t.angle.bis,dir:t.angle.dir},offset:P(t.offset),arc:{radius:P(t.arc.radius),x:t.x+(Math.cos(t.angle.bis)*g||0),y:t.y+(Math.sin(t.angle.bis)*g||0)},in:{length:t.in.length,x:t.x+Math.cos(t.angle.prev)*t.offset,y:t.y+Math.sin(t.angle.prev)*t.offset},out:{length:t.out.length,x:t.x+Math.cos(t.angle.next)*t.offset,y:t.y+Math.sin(t.angle.next)*t.offset},get prev(){return v[(t.id-1+n)%n]},get next(){return v[(t.id+1)%n]}}});return v},C=e=>{const{prev:a,next:n}=e;a.locked&&!n.locked?e.arc.radius=Math.min(Math.max((e.out.length-n.arc.lim*n.angle.vel)/e.angle.vel,e.out.length/(e.angle.vel+n.angle.vel)),e.in.rest/e.angle.vel,e.arc.lim):n.locked&&!a.locked?e.arc.radius=Math.min(Math.max((e.in.length-a.arc.lim*a.angle.vel)/e.angle.vel,e.in.length/(e.angle.vel+a.angle.vel)),e.out.rest/e.angle.vel,e.arc.lim):n.locked&&a.locked?e.arc.radius=Math.min(e.in.rest/e.angle.vel,e.out.rest/e.angle.vel,e.arc.lim):e.arc.radius=Math.min(Math.max((e.in.length-a.arc.lim*a.angle.vel)/e.angle.vel,e.in.length/(e.angle.vel+a.angle.vel)),Math.max((e.out.length-n.arc.lim*n.angle.vel)/e.angle.vel,e.out.length/(e.angle.vel+n.angle.vel)),e.arc.lim),N(e)},H=(e,a)=>{if(a>e.arc.hit){const{prev:n,next:l}=e;n.locked&&!l.locked?e.arc.radius=Math.max(Math.min(e.in.rest/e.angle.vel,e.out.length/(e.angle.vel+l.angle.vel),e.arc.radius),0):l.locked&&!n.locked?e.arc.radius=Math.max(Math.min(e.out.rest/e.angle.vel,e.in.length/(e.angle.vel+n.angle.vel),e.arc.radius),0):l.locked&&n.locked?e.arc.radius=Math.max(Math.min(e.in.rest/e.angle.vel,e.out.rest/e.angle.vel,e.arc.radius),0):e.arc.radius=e.arc.hit}N(e)},N=e=>{const{prev:a,next:n}=e;e.offset=e.arc.radius*e.angle.vel,a.out.rest-=e.offset,e.in.rest-=e.offset,e.out.rest-=e.offset,n.in.rest-=e.offset,e.locked=!0,a.arc.hit=Math.min(a.in.length/(a.angle.vel+a.prev.angle.vel),a.in.rest/a.angle.vel,a.out.rest/a.angle.vel),n.arc.hit=Math.min(n.out.length/(n.angle.vel+n.next.angle.vel),n.out.rest/n.angle.vel,n.in.rest/n.angle.vel)},k=e=>e.reduce((a,n)=>n.locked?a:a?n.arc.hit<a.arc.hit?n:a:n,null);export{T as g,_ as r};
